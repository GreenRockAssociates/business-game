import {MockRabbitMqInteractor} from "./utils/mock-rabbit-mq-interactor";
import {DataSource} from "typeorm";
import {MarketFixture} from "./utils/market-fixture";
import { AppDataSource } from "../../../DataSource/src";
import {generateNewMarketStateListenerFactory} from "../message-broker/listeners/generate-new-market-state.listener";
import {RabbitMqInteractor} from "../message-broker/rabbit-mq-interactor";
import { AssetEntity } from "../../../DataSource/src/entities/asset.entity";
import { GameEntity } from "../../../DataSource/src/entities/game.entity";
import {MarketSimulationIncomingMessageDTO} from "../dto/market-simulation-incoming-message.dto";
import { MarketEntity } from "../../../DataSource/src/entities/market.entity";
import {MarketStateOutgoingMessageDto} from "../dto/market-state-outgoing-message.dto";

// Used to change the value generated by the normal distribution
const mockNormalDistributionGetter = jest.fn();
jest.mock("../libraries/normal-distribution", () => ({
    get NormalDistribution() {
        return mockNormalDistributionGetter();
    }
}));
function fakeNormalDistributionClassFactory(returnedValue: number){
    return class NormalDistribution {
        static generate(){
            return returnedValue
        }
    }
}

function truncateNumber(value: number, decimalsToKeep: number) {
    let multiplier = Math.pow(10, decimalsToKeep || 0);
    return Math.floor(value * multiplier) / multiplier;
}

describe("Generate new market state listener", () => {
    let rabbitMqInteractor: MockRabbitMqInteractor;

    let dataSource: DataSource;
    let marketFixture: MarketFixture;

    let generateNewMarketStateListener: (arg0: MarketSimulationIncomingMessageDTO) => void;

    beforeAll(async () => {
        dataSource = await AppDataSource.initialize().catch((error: Error) => {
            throw new Error(`Error initializing database: ${error.message}`);
        }) as unknown as DataSource;

        marketFixture = new MarketFixture(dataSource);
        await marketFixture.resetDB();
    })

    beforeEach(async () => {
        mockNormalDistributionGetter.mockReturnValue(fakeNormalDistributionClassFactory(0.5));
        rabbitMqInteractor = new MockRabbitMqInteractor();
        generateNewMarketStateListener = generateNewMarketStateListenerFactory(rabbitMqInteractor as unknown as RabbitMqInteractor, dataSource);
    })

    afterEach(async () => {
        await marketFixture.resetDB();
    })

    afterAll(async () => {
        await dataSource.destroy();
    });

    it("Should generate a new market state from the provided info", async () => {
        const game: GameEntity = await marketFixture.insertGame();
        const asset: AssetEntity = await marketFixture.insertAsset();
        const incomingMessage = new MarketSimulationIncomingMessageDTO(game.id, 1, [[asset.ticker, 10]], [[asset.ticker, 0.5]]);

        await generateNewMarketStateListener(incomingMessage);

        const marketRepository = dataSource.getRepository(MarketEntity);
        const marketEntries: MarketEntity[] = await marketRepository.find({
            relations: {
                asset: true,
                game: true
            }
        });
        expect(marketEntries.length).toEqual(1);
        expect(marketEntries[0].asset).toEqual(asset);
        expect(marketEntries[0].game).toEqual(game);
        expect(marketEntries[0].tick).toEqual(incomingMessage.tick);
        expect(marketEntries[0].tradable).toEqual(true);
    })

    it("Should emit the new market state", async () => {
        const game: GameEntity = await marketFixture.insertGame();
        const asset: AssetEntity = await marketFixture.insertAsset();
        const incomingMessage = new MarketSimulationIncomingMessageDTO(game.id, 1, [[asset.ticker, 10]], [[asset.ticker, 0.5]]);

        await generateNewMarketStateListener(incomingMessage);

        const marketRepository = dataSource.getRepository(MarketEntity);
        const marketEntry: MarketEntity = await marketRepository.findOne({
            where: {
                asset: asset,
                game: game
            }
        });
        expect(rabbitMqInteractor.sendToMarketStateQueue).toHaveBeenCalledTimes(1);
        expect(rabbitMqInteractor.sendToMarketStateQueue).toHaveBeenCalledWith(
            new MarketStateOutgoingMessageDto(
                game.id,
                incomingMessage.tick,
                [[marketEntry.assetTicker, marketEntry.value]]
            )
        )
    })

    it("Should increase the price if the probability is 1", async () => {
        const normalDistributionValue = 0.5;
        const baseAssetPrice = 10;
        mockNormalDistributionGetter.mockReturnValue(fakeNormalDistributionClassFactory(normalDistributionValue));
        const game: GameEntity = await marketFixture.insertGame();
        const asset: AssetEntity = await marketFixture.insertAsset();
        const incomingMessage = new MarketSimulationIncomingMessageDTO(game.id, 1, [[asset.ticker, baseAssetPrice]], [[asset.ticker, 1]]);

        await generateNewMarketStateListener(incomingMessage);

        const marketRepository = dataSource.getRepository(MarketEntity);
        const marketEntry: MarketEntity = await marketRepository.findOne({
            where: {
                asset: asset,
                game: game
            }
        });
        expect(marketEntry.value).toEqual(truncateNumber(baseAssetPrice + (normalDistributionValue * baseAssetPrice / 120), 2));
    })

    it("Should decrease the price if the probability is 0", async () => {
        const normalDistributionValue = 0.5;
        const baseAssetPrice = 10;
        mockNormalDistributionGetter.mockReturnValue(fakeNormalDistributionClassFactory(normalDistributionValue));
        const game: GameEntity = await marketFixture.insertGame();
        const asset: AssetEntity = await marketFixture.insertAsset();
        const incomingMessage = new MarketSimulationIncomingMessageDTO(game.id, 1, [[asset.ticker, baseAssetPrice]], [[asset.ticker, 0]]);

        await generateNewMarketStateListener(incomingMessage);

        const marketRepository = dataSource.getRepository(MarketEntity);
        const marketEntry: MarketEntity = await marketRepository.findOne({
            where: {
                asset: asset,
                game: game
            }
        });
        expect(marketEntry.value).toEqual(truncateNumber(baseAssetPrice - (normalDistributionValue * baseAssetPrice / 120), 2));
    })
})